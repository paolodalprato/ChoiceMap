<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChoiceMap - Interactive Decision Tree</title>
    <meta name="description" content="ChoiceMap: A framework for documenting multi-choice processes through interactive decision trees">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="shared-utils.js"></script>
    <link rel="stylesheet" href="shared-styles.css">
    <style>
        * { box-sizing: border-box; }
        body { margin: 0; padding: 0; font-family: var(--font-family, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif); background: var(--bg); min-height: 100vh; overflow-x: hidden; }
        .slide-container { height: 100vh; display: flex; flex-direction: column; overflow: hidden; }
        .slide-content { flex: 1; display: flex; flex-direction: column; padding: 0 2rem; max-width: 1200px; margin: 0 auto; width: 100%; min-height: 0; overflow: hidden; }
        .content-scroll { flex: 1; overflow-y: auto; display: flex; flex-direction: column; min-height: 0; }
        .content-inner { margin: auto 0; flex-shrink: 0; }
        .slide-footer { flex-shrink: 0; padding-bottom: 0.5rem; }
        .slide-content h1 { color: var(--text); font-size: 2rem; margin-bottom: 1rem; font-weight: 600; }
        .slide-content h2 { color: var(--text); font-size: 1.25rem; margin-bottom: 0.75rem; font-weight: 500; }
        .slide-content p { color: var(--text-secondary); font-size: 1rem; line-height: 1.5; margin-bottom: 0.75rem; }
        .slide-content ul { color: var(--text-secondary); font-size: 1rem; line-height: 1.5; margin-bottom: 0.75rem; padding-left: 1.5rem; }
        .slide-content li { margin-bottom: 0.35rem; }
        .slide-content blockquote { border-left: 4px solid var(--accent); padding: 0.75rem 1rem; margin: 1rem 0; color: var(--text-secondary); font-style: italic; background: color-mix(in srgb, var(--accent) 8%, transparent); border-radius: 0 8px 8px 0; }
        .slide-content strong { color: var(--text); font-weight: 600; }
        .slide-content em { color: var(--text-secondary); }
        .choices-container { display: flex; flex-wrap: wrap; gap: 0.75rem; margin-top: 1rem; justify-content: flex-start; }
        .choice-button { background: var(--choice-bg); color: var(--choice-text); border: none; padding: 0.75rem 1.25rem; border-radius: 12px; font-size: 1rem; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 4px 15px color-mix(in srgb, var(--choice-bg) 30%, transparent); min-width: 160px; text-align: center; }
        .choice-button:hover { transform: translateY(-2px); box-shadow: 0 6px 20px color-mix(in srgb, var(--choice-bg) 40%, transparent); }
        .choice-button.visited { background: var(--visited-bg); color: var(--visited-text); }
        .choice-button.visited::after { content: ' ‚úì'; }

        .header-bar { display: flex; justify-content: space-between; align-items: center; padding: 0.75rem 1rem; width: 100%; flex-shrink: 0; }
        .scenario-title { color: var(--text); font-size: 1rem; font-weight: 500; max-width: 50%; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .brand-header { display: flex; align-items: center; gap: 0.75rem; }
        .progress-indicator { color: var(--text-muted); font-size: 0.875rem; padding: 0.5rem 1rem; flex-shrink: 0; }
        .map-button { position: fixed; bottom: 1rem; right: 1rem; background: color-mix(in srgb, var(--accent) 10%, transparent); border: 1px solid var(--accent); color: var(--accent-hover); padding: 0.75rem 1.25rem; border-radius: 8px; cursor: pointer; transition: all 0.3s ease; display: flex; align-items: center; gap: 0.5rem; z-index: 100; }
        .map-button:hover { background: color-mix(in srgb, var(--accent) 20%, transparent); }
        .restart-button { background: var(--success); color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 12px; font-size: 1rem; cursor: pointer; transition: all 0.3s ease; margin-top: 0.75rem; }
        .restart-button:hover { transform: translateY(-2px); }
        .terminal-badge { display: block; background: var(--restart-bg); color: var(--restart-text); padding: 0.5rem 1rem; border-radius: 20px; font-size: 0.875rem; margin-top: 1rem; margin-bottom: 0.5rem; width: 100%; text-align: center; flex-shrink: 0; }
        .back-button { position: fixed; top: 1rem; left: 50%; transform: translateX(-50%); background: var(--back-bg, #f97316); border: 1px solid var(--back-bg, #f97316); color: var(--back-text, #ffffff); padding: 0.5rem 1.25rem; border-radius: 20px; cursor: pointer; transition: all 0.3s ease; font-size: 0.875rem; display: flex; align-items: center; gap: 0.5rem; z-index: 50; }
        .back-button:hover { background: color-mix(in srgb, var(--back-bg, #f97316) 85%, black); border-color: color-mix(in srgb, var(--back-bg, #f97316) 85%, black); color: var(--back-text, #ffffff); }
        .back-button svg { width: 16px; height: 16px; }
        .resources-section { margin-top: 1rem; padding-top: 0.75rem; border-top: 1px solid var(--border); }
        .resources-title { color: var(--text); font-size: 0.875rem; margin-bottom: 1rem; text-transform: uppercase; letter-spacing: 0.05em; font-weight: 800; }
        .resource-link { display: inline-flex; align-items: center; gap: 0.5rem; color: var(--accent-hover); text-decoration: none; padding: 0.5rem 1rem; background: color-mix(in srgb, var(--accent) 8%, transparent); border-radius: 6px; margin-right: 0.75rem; margin-bottom: 0.75rem; transition: all 0.3s ease; }
        .resource-link:hover { background: color-mix(in srgb, var(--accent) 15%, transparent); }
        .map-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: var(--bg); z-index: 200; display: flex; flex-direction: column; }
        .map-header { display: flex; justify-content: space-between; align-items: center; padding: 1rem 1.5rem; border-bottom: 1px solid var(--border); }
        .map-header h2 { color: var(--text); font-size: 1.25rem; margin: 0; flex: 1; }
        .map-toolbar { display: flex; gap: 0.5rem; align-items: center; }
        .map-toolbar button { padding: 0.5rem 1rem; border-radius: 6px; cursor: pointer; font-size: 0.875rem; transition: all 0.2s; }
        .btn-secondary { background: color-mix(in srgb, var(--accent) 10%, transparent); border: 1px solid var(--accent); color: var(--accent-hover); }
        .btn-secondary:hover { background: color-mix(in srgb, var(--accent) 20%, transparent); }
        .close-button { background: #ef4444; border: none; color: white; cursor: pointer; padding: 0.5rem 1rem; border-radius: 6px; font-size: 1rem; font-weight: 600; }
        .close-button:hover { background: #dc2626; }
        .map-content { flex: 1; overflow: auto; display: flex; align-items: center; justify-content: center; padding: 2rem; background: #f3f4f6; }
        .map-footer { padding: 0.75rem 1.5rem; border-top: 1px solid var(--border); font-size: 0.8rem; color: var(--text-muted); }
        .tree-node { transition: all 0.3s ease; }
        .tree-node:hover { filter: brightness(1.2); }
        .tree-node.visited { cursor: pointer; }
        .tree-node.not-visited { opacity: 0.7; cursor: pointer; }
        .tree-node.current { filter: brightness(1.1); }
        .loading { display: flex; justify-content: center; align-items: center; min-height: 100vh; color: var(--text-secondary); font-size: 1.25rem; }
        .error { display: flex; justify-content: center; align-items: center; min-height: 100vh; color: #ef4444; font-size: 1.25rem; flex-direction: column; gap: 1rem; }
        .brand-logo { height: 32px; width: auto; }
        .brand-name { color: var(--text); font-size: 0.9rem; font-weight: 500; }
        .brand-name a { color: inherit; text-decoration: none; }
        .brand-name a:hover { color: var(--accent); }
    </style>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // Module-level mutables: safe because the loading state blocks
        // React render until all fetches complete. No race condition.
        let fontOptions = {};
        let defaultTheme = {};
        let layoutConfig = { levelHeight: 120, nodeWidth: 140, nodeHeight: 44, padding: 60 };

        const loadGoogleFont = (fontKey) => {
            const font = fontOptions[fontKey];
            if (!font || !font.google) return;
            const fontName = font.name.replace(/ /g, '+');
            let link = document.getElementById('google-font-link');
            if (!link) { link = document.createElement('link'); link.id = 'google-font-link'; link.rel = 'stylesheet'; document.head.appendChild(link); }
            link.href = `https://fonts.googleapis.com/css2?family=${fontName}:wght@400;500;600;700;800&display=swap`;
        };

        const applyTheme = (theme) => {
            const root = document.documentElement;
            const t = { ...defaultTheme, ...theme };
            const c = { ...defaultTheme.colors, ...t.colors };
            const b = { ...defaultTheme.buttons, ...t.buttons };
            const m = { ...defaultTheme.map, ...t.map };
            const typ = { ...defaultTheme.typography, ...t.typography };
            const fontKey = typ.fontFamily || 'system';
            const font = fontOptions[fontKey] || fontOptions['system'];
            loadGoogleFont(fontKey);
            root.style.setProperty('--font-family', font?.family || 'system-ui');
            root.style.setProperty('--bg', c.background);
            root.style.setProperty('--text', c.text);
            root.style.setProperty('--text-secondary', c.textSecondary);
            root.style.setProperty('--text-muted', c.textMuted);
            root.style.setProperty('--accent', c.accent);
            root.style.setProperty('--accent-hover', c.accentHover);
            root.style.setProperty('--success', c.success);
            root.style.setProperty('--warning', c.warning);
            root.style.setProperty('--border', c.border);
            root.style.setProperty('--choice-bg', b.choiceBackground);
            root.style.setProperty('--choice-text', b.choiceText);
            root.style.setProperty('--visited-bg', b.visitedBackground);
            root.style.setProperty('--visited-text', b.visitedText);

            root.style.setProperty('--restart-bg', b.restartBackground);
            root.style.setProperty('--restart-text', b.restartText);
            root.style.setProperty('--back-bg', b.backBackground);
            root.style.setProperty('--back-text', b.backText);
            root.style.setProperty('--map-node-visited', m.nodeVisited);
            root.style.setProperty('--map-node-visited-text', m.nodeVisitedText);
            root.style.setProperty('--map-node-current', m.nodeCurrent);
            root.style.setProperty('--map-node-current-text', m.nodeCurrentText);
            root.style.setProperty('--map-node-unvisited', m.nodeUnvisited);
            root.style.setProperty('--map-node-unvisited-text', m.nodeUnvisitedText);
            root.style.setProperty('--map-node-unvisited-border', m.nodeUnvisitedBorder);
            root.style.setProperty('--map-line-visited', m.lineVisited);
            root.style.setProperty('--map-line-unvisited', m.lineUnvisited);
        };

        const getText = (value) => {
            if (typeof value === 'string') return value;
            if (value && typeof value === 'object') return value[Object.keys(value)[0]] || '';
            return '';
        };

        // Use shared utilities from shared-utils.js
        const { calculateNodeLevels, calculateAutoPositions, RESOURCE_ICONS, RESOURCE_LABELS, sanitizeUrl, ErrorBoundary, getConnectionPath: sharedGetConnectionPath, getArrowPosition: sharedGetArrowPosition, getConnectionColor: sharedGetConnectionColor } = window.ChoiceMapUtils;

        // Wrapper for calculateAutoPositions to use local layoutConfig
        const calculateAutoPositionsWithConfig = (nodes, startNode) => {
            return calculateAutoPositions(nodes, startNode, layoutConfig);
        };

        const MarkdownContent = ({ content }) => {
            const parseMarkdown = (text) => {
                if (!text) return [];
                const lines = text.split('\n');
                const elements = [];
                let currentList = [];
                const processInline = (line) => {
                    const escaped = window.ChoiceMapUtils.escapeHtml(line);
                    return escaped
                        .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
                        .replace(/\*(.+?)\*/g, '<em>$1</em>');
                };
                const flushList = () => { if (currentList.length > 0) { elements.push(<ul key={`list-${elements.length}`}>{currentList.map((item, i) => <li key={i} dangerouslySetInnerHTML={{ __html: processInline(item) }} />)}</ul>); currentList = []; } };
                lines.forEach((line, index) => {
                    if (line.startsWith('# ')) { flushList(); elements.push(<h1 key={index} dangerouslySetInnerHTML={{ __html: processInline(line.slice(2)) }} />); }
                    else if (line.startsWith('## ')) { flushList(); elements.push(<h2 key={index} dangerouslySetInnerHTML={{ __html: processInline(line.slice(3)) }} />); }
                    else if (line.startsWith('> ')) { flushList(); elements.push(<blockquote key={index} dangerouslySetInnerHTML={{ __html: processInline(line.slice(2)) }} />); }
                    else if (line.startsWith('- ')) { currentList.push(line.slice(2)); }
                    else if (line.trim()) { flushList(); elements.push(<p key={index} dangerouslySetInnerHTML={{ __html: processInline(line) }} />); }
                    else { flushList(); }
                });
                flushList();
                return elements;
            };
            return <>{parseMarkdown(content)}</>;
        };

        const TreeMap = ({ scenarioData, nodes, visitedNodes, currentNode, onNodeClick, onClose, translations }) => {
            const [nodePositions, setNodePositions] = useState({});
            const [svgSize, setSvgSize] = useState({ width: 800, height: 600 });
            const svgRef = useRef(null);
            const { nodeWidth, nodeHeight, padding } = layoutConfig;

            useEffect(() => {
                const autoLayout = calculateAutoPositionsWithConfig(nodes, scenarioData.startNode);
                const positions = {};
                Object.keys(nodes).forEach(nodeId => {
                    const pos = nodes[nodeId].position;
                    // Use auto-layout if position is missing or is placeholder (0,0)
                    const isPlaceholder = !pos || (pos.x === 0 && pos.y === 0);
                    positions[nodeId] = isPlaceholder ? (autoLayout.positions[nodeId] || { x: padding, y: padding }) : { ...pos };
                });
                setNodePositions(positions);
                const allX = Object.values(positions).map(p => p.x);
                const allY = Object.values(positions).map(p => p.y);
                setSvgSize({ width: Math.max(...allX, 400) + nodeWidth + padding, height: Math.max(...allY, 300) + nodeHeight + padding });
            }, [nodes, scenarioData.startNode]);

            // Double-click to navigate to any node
            const handleNodeDoubleClick = (e, nodeId) => {
                onNodeClick(nodeId);
            };

            const connections = [];
            // Calculate logical levels for loop detection (reuse shared BFS)
            const levelGroups = calculateNodeLevels(nodes, scenarioData.startNode);
            const nodeLevels = {};
            Object.entries(levelGroups).forEach(([level, nodeIds]) => {
                nodeIds.forEach(id => { nodeLevels[id] = parseInt(level); });
            });
            
            Object.entries(nodes).forEach(([nodeId, node]) => {
                if (node.choices && nodePositions[nodeId]) {
                    node.choices.forEach((choice, idx) => {
                        if (choice.next && nodePositions[choice.next]) {
                            const fromLevel = nodeLevels[nodeId] ?? 0;
                            const toLevel = nodeLevels[choice.next] ?? 0;
                            connections.push({ 
                                from: nodePositions[nodeId], 
                                to: nodePositions[choice.next], 
                                fromId: nodeId, 
                                toId: choice.next, 
                                fromLevel,
                                toLevel,
                                isLoop: toLevel < fromLevel,
                                isSameLevel: toLevel === fromLevel,
                                visited: visitedNodes.has(nodeId) && visitedNodes.has(choice.next), 
                                key: `${nodeId}-${choice.next}-${idx}` 
                            });
                        }
                    });
                }
            });

            const getNodeLabel = (nodeId) => {
                const node = nodes[nodeId];
                if (!node) return nodeId;
                const content = getText(node.content);
                const match = content.match(/^#\s+(.+)$/m);
                if (match) { const title = match[1].replace(/\*\*/g, ''); return title.length > 15 ? title.slice(0, 12) + '...' : title; }
                return nodeId;
            };

            const getConnectionPathLocal = (conn) => sharedGetConnectionPath(conn, nodeHeight);
            const getArrowPositionLocal = sharedGetArrowPosition;
            const getConnectionColorLocal = sharedGetConnectionColor;

            return (
                <div className="map-overlay">
                    <div className="map-header">
                        <h2>{translations.mapOf} {scenarioData.meta?.title || 'Scenario'}</h2>
                        <div className="map-toolbar">
                            <button className="close-button" onClick={onClose}>X</button>
                        </div>
                    </div>
                    <div className="map-content">
                        <svg ref={svgRef} width={svgSize.width} height={svgSize.height} style={{ display: 'block', margin: 'auto', background: '#ffffff', border: '1px solid #e5e7eb', borderRadius: '8px' }}>
                            {connections.map((conn) => {
                                const pathData = getConnectionPathLocal(conn);
                                const arrowPos = getArrowPositionLocal(pathData);
                                const color = getConnectionColorLocal(conn);
                                return (
                                    <g key={conn.key}>
                                        <path d={pathData.path} fill="none" stroke={color} strokeWidth={2} />
                                        <polygon points="-8,-5 8,0 -8,5" fill={color} transform={`translate(${arrowPos.x}, ${arrowPos.y}) rotate(${arrowPos.angle})`} />
                                    </g>
                                );
                            })}
                            {Object.entries(nodePositions).map(([nodeId, pos]) => {
                                if (!nodes[nodeId]) return null;
                                const isVisited = visitedNodes.has(nodeId);
                                const isCurrent = nodeId === currentNode;
                                let fill, stroke, textFill;
                                if (isCurrent) { fill = 'var(--map-node-current)'; stroke = 'var(--map-node-current)'; textFill = 'var(--map-node-current-text)'; }
                                else if (isVisited) { fill = 'var(--map-node-visited)'; stroke = 'var(--map-node-visited)'; textFill = 'var(--map-node-visited-text)'; }
                                else { fill = 'var(--map-node-unvisited)'; stroke = 'var(--map-node-unvisited-border)'; textFill = 'var(--map-node-unvisited-text)'; }
                                return (
                                    <g key={nodeId}
                                       className={`tree-node ${isVisited ? 'visited' : 'not-visited'} ${isCurrent ? 'current' : ''}`}
                                       style={{ cursor: 'pointer' }}
                                       onDoubleClick={(e) => handleNodeDoubleClick(e, nodeId)}>
                                        <rect x={pos.x - nodeWidth/2 + 10} y={pos.y - nodeHeight/2} width={nodeWidth - 20} height={nodeHeight} rx={8} fill={fill} stroke={stroke} strokeWidth={2} />
                                        <text x={pos.x} y={pos.y + 4} textAnchor="middle" dominantBaseline="middle" fill={textFill} fontSize="11" fontWeight="800" style={{ pointerEvents: 'none', userSelect: 'none' }}>{getNodeLabel(nodeId)}</text>
                                    </g>
                                );
                            })}
                        </svg>
                    </div>
                    <div className="map-footer">üí° Double-click on any node to go to that card</div>
                </div>
            );
        };

        const ChoiceMap = () => {
            const [scenarioData, setScenarioData] = useState(null);
            const [theme, setTheme] = useState(null);
            const [currentNode, setCurrentNode] = useState(null);
            const [visitedNodes, setVisitedNodes] = useState(new Set());
            const [history, setHistory] = useState([]);
            const [showMap, setShowMap] = useState(false);
            const [loading, setLoading] = useState(true);
            const [error, setError] = useState(null);
            const [showCredits, setShowCredits] = useState(true);

            useEffect(() => {
                const loadAll = async () => {
                    try {
                        const defaultsRes = await fetch('defaults.json?v=' + Date.now());
                        if (defaultsRes.ok) {
                            const defaults = await defaultsRes.json();
                            if (defaults.fontOptions) fontOptions = defaults.fontOptions;
                            if (defaults.defaultTheme) defaultTheme = defaults.defaultTheme;
                            if (defaults.layout) layoutConfig = { ...layoutConfig, ...defaults.layout };
                        }
                        const configRes = await fetch('config.json?v=' + Date.now());
                        if (!configRes.ok) throw new Error('config.json not found');
                        const config = await configRes.json();
                        if (config.showCredits === false) setShowCredits(false);
                        const scenarioFile = config.scenario || 'scenario.json';
                        const themeFile = config.theme || 'theme.json';
                        const [scenarioRes, themeRes] = await Promise.all([fetch(scenarioFile + '?v=' + Date.now()), fetch(themeFile + '?v=' + Date.now())]);
                        if (!scenarioRes.ok) throw new Error(`Scenario file not found: ${scenarioFile}`);
                        const scenario = await scenarioRes.json();
                        const themeData = themeRes.ok ? await themeRes.json() : {};
                        applyTheme(themeData);
                        setScenarioData(scenario);
                        setTheme(themeData);
                        setCurrentNode(scenario.startNode);
                        setVisitedNodes(new Set([scenario.startNode]));
                        setHistory([scenario.startNode]);
                        setLoading(false);
                    } catch (err) { setError(err.message); setLoading(false); }
                };
                loadAll();
            }, []);

            const translations = { step: 'Step', restart: 'Start Over', endOfPath: 'End of this path', resources: 'Resources', viewMap: 'View Map', mapOf: 'Map of', back: 'Back', download: 'Download', openLink: 'Open', watchVideo: 'Watch', ...scenarioData?.translations };
            const handleChoice = (nextNode) => { setVisitedNodes(prev => new Set([...prev, nextNode])); setHistory(prev => [...prev, nextNode]); setCurrentNode(nextNode); window.scrollTo(0, 0); };
            const handleBack = () => { if (history.length > 1) { const newHistory = history.slice(0, -1); setHistory(newHistory); setCurrentNode(newHistory[newHistory.length - 1]); window.scrollTo(0, 0); } };
            const handleRestart = () => { setCurrentNode(scenarioData.startNode); setVisitedNodes(new Set([scenarioData.startNode])); setHistory([scenarioData.startNode]); window.scrollTo(0, 0); };
            const handleMapNodeClick = (nodeId) => {
                setVisitedNodes(prev => new Set([...prev, nodeId]));
                if (nodeId === scenarioData.startNode) {
                    // Reset history when navigating to start
                    setHistory([scenarioData.startNode]);
                    setCurrentNode(scenarioData.startNode);
                } else {
                    setHistory(prev => {
                        // Don't duplicate if already last in history
                        if (prev[prev.length - 1] === nodeId) return prev;
                        return [...prev, nodeId];
                    });
                    setCurrentNode(nodeId);
                }
                setShowMap(false);
                window.scrollTo(0, 0);
            };

            if (loading) return <div className="loading">Loading...</div>;
            if (error) return <div className="error"><span>Error: {error}</span></div>;
            if (!scenarioData || !currentNode) return <div className="error"><span>No scenario data</span></div>;

            const node = scenarioData.nodes[currentNode];
            if (!node) return <div className="error"><span>Node not found: {currentNode}</span></div>;

            const content = getText(node.content);
            const choices = node.choices || [];
            const resources = node.resources || [];
            const isTerminal = choices.length === 0;
            const currentIndex = history.length;

            const getResourceIcon = (type) => RESOURCE_ICONS[type] || RESOURCE_ICONS.link;
            const getResourceLabel = (type) => {
                if (type === 'video') return translations.watchVideo;
                if (type === 'download') return translations.download;
                return translations.openLink;
            };

            return (
                <div className="slide-container">
                    <div className="header-bar">
                        <div className="scenario-title">{scenarioData.meta?.title}</div>
                        <div className="brand-header">
                            {theme?.brand?.logo && (
                                theme?.brand?.website
                                    ? <a href={sanitizeUrl(theme.brand.website)} target="_blank" rel="noopener noreferrer"><img src={sanitizeUrl(theme.brand.logo)} alt="Logo" className="brand-logo" /></a>
                                    : <img src={sanitizeUrl(theme.brand.logo)} alt="Logo" className="brand-logo" />
                            )}
                            {theme?.brand?.name && (
                                theme?.brand?.website
                                    ? <a href={sanitizeUrl(theme.brand.website)} target="_blank" rel="noopener noreferrer" className="brand-name">{theme.brand.name}</a>
                                    : <span className="brand-name">{theme.brand.name}</span>
                            )}
                        </div>
                    </div>
                    {history.length > 1 && currentNode !== scenarioData.startNode && (
                        <button className="back-button" onClick={handleBack}>
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M19 12H5M12 19l-7-7 7-7"/></svg>
                            {translations.back}
                        </button>
                    )}
                    <div className="slide-content">
                        {isTerminal && <span className="terminal-badge">{translations.endOfPath}</span>}
                        <div className="content-scroll">
                            <div className="content-inner">
                                <MarkdownContent content={content} />
                            </div>
                        </div>
                        <div className="slide-footer">
                            {choices.length > 0 && (
                                <div className="choices-container">
                                    {choices.map((choice, index) => (
                                        <button key={index} className={`choice-button ${visitedNodes.has(choice.next) ? 'visited' : ''}`} onClick={() => handleChoice(choice.next)}>
                                            {getText(choice.text)}
                                        </button>
                                    ))}
                                </div>
                            )}
                            {isTerminal && <button className="restart-button" onClick={handleRestart}>{translations.restart}</button>}
                            {resources.length > 0 && (
                                <div className="resources-section">
                                    <div className="resources-title">{translations.resources}</div>
                                    {resources.map((res, i) => (
                                        <a key={i} href={sanitizeUrl(res.url)} target="_blank" rel="noopener noreferrer" className="resource-link" download={res.type === 'download' ? true : undefined}>
                                            {getResourceIcon(res.type)} {getText(res.label) || getResourceLabel(res.type)}
                                        </a>
                                    ))}
                                </div>
                            )}
                        </div>
                    </div>
                    <div className="progress-indicator">{translations.step} {currentIndex}</div>
                    <button className="map-button" onClick={() => setShowMap(true)}>üó∫Ô∏è {translations.viewMap}</button>
                    {showMap && <TreeMap scenarioData={scenarioData} nodes={scenarioData.nodes} visitedNodes={visitedNodes} currentNode={currentNode} onNodeClick={handleMapNodeClick} onClose={() => setShowMap(false)} translations={translations} />}
                </div>
            );
        };

        ReactDOM.createRoot(document.getElementById('root')).render(
            <ErrorBoundary fallbackMessage="The Navigator encountered an error. Please reload the page.">
                <ChoiceMap />
            </ErrorBoundary>
        );
    </script>
</body>
</html>
